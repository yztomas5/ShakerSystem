-- Module: ShakerJuice.lua
-- Ubicación: ReplicatedStorage.Modules.Utils.ShakerLogic

local ShakerJuice = {}

-- Calcular PricePerSec con mutaciones
function ShakerJuice.CalculateIngredientPPS(ingredientFolder, ingredientData, mutationConfig)
	local basePPS = ingredientData.PricePerSec
	local multiplier = 1

	for _, child in ipairs(ingredientFolder:GetChildren()) do
		if child:IsA("StringValue") and mutationConfig[child.Name] then
			multiplier = multiplier * mutationConfig[child.Name].Multiplier
		end
	end

	return basePPS * multiplier
end

-- Determinar calidad resultante del jugo
function ShakerJuice.DetermineJuiceQuality(ingredientQualities)
	local qualityOrder = {"Rare", "Unusual", "Mythical", "Legendary", "Divine", "Celestial"}
	local qualityValues = {}

	for _, quality in ipairs(ingredientQualities) do
		for i, q in ipairs(qualityOrder) do
			if q == quality then
				table.insert(qualityValues, i)
				break
			end
		end
	end

	if #qualityValues == 0 then return "Rare" end

	table.sort(qualityValues)
	local avgValue = 0
	for _, v in ipairs(qualityValues) do
		avgValue = avgValue + v
	end
	avgValue = math.floor(avgValue / #qualityValues + 0.5)

	return qualityOrder[avgValue] or "Rare"
end

-- Determinar modelo (categoría) del jugo
function ShakerJuice.DetermineJuiceModel(sortedIngredients)
	if #sortedIngredients == 0 then return "Basic" end

	local rand = math.random(1, 100)

	if #sortedIngredients == 1 then
		return sortedIngredients[1].category
	elseif #sortedIngredients == 2 then
		if rand <= 40 then
			return sortedIngredients[1].category
		else
			return sortedIngredients[2].category
		end
	else -- 3 ingredientes
		if rand <= 10 then
			return sortedIngredients[1].category
		elseif rand <= 50 then
			return sortedIngredients[2].category
		else
			return sortedIngredients[3].category
		end
	end
end

-- Generar ID único para el jugo
function ShakerJuice.GenerateUniqueJuiceId(juicesFolder)
	local baseId = tick() * 1000 -- Usar timestamp en milisegundos como base
	local juiceId = math.floor(baseId)

	-- Verificar que no exista ya un jugo con este ID
	while ShakerJuice.JuiceExistsWithId(juicesFolder, juiceId) do
		juiceId = juiceId + 1
	end

	return juiceId
end

-- Verificar si existe un jugo con el ID especificado
function ShakerJuice.JuiceExistsWithId(juicesFolder, targetId)
	for _, juiceFolder in ipairs(juicesFolder:GetChildren()) do
		if juiceFolder:IsA("Folder") then
			local idValue = juiceFolder:FindFirstChild("Id")
			if idValue and idValue:IsA("IntValue") and idValue.Value == targetId then
				return true
			end
		end
	end
	return false
end

-- Crear jugo desde ingredientes del shaker
function ShakerJuice.CreateJuice(player, shakerNumber, ingredientFolders, ingredientConfig, mutationConfig)
	local inventory = player:FindFirstChild("Inventory")
	if not inventory then return false end

	local juicesFolder = inventory:FindFirstChild("Juices")
	if not juicesFolder then
		juicesFolder = Instance.new("Folder")
		juicesFolder.Name = "Juices"
		juicesFolder.Parent = inventory
	end

	if #ingredientFolders == 0 then return false end

	-- Procesar información de ingredientes
	local ingredientsData = {}
	local totalPrice = 0
	local totalPPS = 0
	local qualities = {}

	for _, folder in ipairs(ingredientFolders) do
		local ingredientName = folder.Name
		local ingredientInfo = ingredientConfig.Ingredients[ingredientName]

		if ingredientInfo then
			local pps = ShakerJuice.CalculateIngredientPPS(folder, ingredientInfo, mutationConfig)

			table.insert(ingredientsData, {
				folder = folder,
				name = ingredientName,
				price = ingredientInfo.Price,
				pps = pps,
				pronoun = ingredientInfo.Pronoun,
				category = ingredientInfo.Category,
				quality = ingredientInfo.Quality
			})

			totalPrice = totalPrice + ingredientInfo.Price
			totalPPS = totalPPS + pps
			table.insert(qualities, ingredientInfo.Quality)
		end
	end

	-- Ordenar de mejor a peor
	table.sort(ingredientsData, function(a, b) return a.price > b.price end)

	-- Determinar calidad y modelo
	local juiceQuality = ShakerJuice.DetermineJuiceQuality(qualities)
	local juiceModel = ShakerJuice.DetermineJuiceModel(ingredientsData)

	-- Construir nombre del jugo
	local pronouns = {}
	for _, data in ipairs(ingredientsData) do
		table.insert(pronouns, data.pronoun)
	end
	local juiceName = juiceModel .. " " .. table.concat(pronouns, " ")

	-- Generar ID único para evitar duplicados
	local juiceId = ShakerJuice.GenerateUniqueJuiceId(juicesFolder)

	-- Crear folder del jugo
	local juiceFolder = Instance.new("Folder")
	juiceFolder.Name = juiceName
	juiceFolder.Parent = juicesFolder

	-- Crear ID único
	local idValue = Instance.new("IntValue")
	idValue.Name = "Id"
	idValue.Value = juiceId
	idValue.Parent = juiceFolder

	-- Crear propiedades
	local qualityValue = Instance.new("StringValue")
	qualityValue.Name = "Quality"
	qualityValue.Value = juiceQuality
	qualityValue.Parent = juiceFolder

	local modelValue = Instance.new("StringValue")
	modelValue.Name = "Model"
	modelValue.Value = juiceModel
	modelValue.Parent = juiceFolder

	local priceValue = Instance.new("IntValue")
	priceValue.Name = "Price"
	priceValue.Value = totalPrice
	priceValue.Parent = juiceFolder

	local ppsValue = Instance.new("IntValue")
	ppsValue.Name = "PricePerSec"
	ppsValue.Value = math.floor(totalPPS)
	ppsValue.Parent = juiceFolder

	local slotValue = Instance.new("IntValue")
	slotValue.Name = "Slot"
	slotValue.Value = 0
	slotValue.Parent = juiceFolder

	-- Crear carpeta de ingredientes
	local ingredientsContainer = Instance.new("Folder")
	ingredientsContainer.Name = "Ingredients"
	ingredientsContainer.Parent = juiceFolder

	-- Mover ingredientes y eliminar sus IDs
	for _, data in ipairs(ingredientsData) do
		local folder = data.folder
		local idValue = folder:FindFirstChild("Id")
		if idValue then
			idValue:Destroy()
		end
		folder.Parent = ingredientsContainer
	end

	print("✅ Juice created: " .. juiceName .. " | ID: " .. juiceId .. " | Quality: " .. juiceQuality .. " | Model: " .. juiceModel)
	return true
end

return ShakerJuice
